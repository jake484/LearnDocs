<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MTK手动空间离散求解PDE · LearnDocs</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.jpg" alt="LearnDocs logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LearnDocs</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Modeling</span><ul><li><a class="tocitem" href="../../Modeling/DE_intro/">DifferentialEquations建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_intro/">ModelingToolkit建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_register/">ModelingToolkit调用外部函数</a></li><li><a class="tocitem" href="../../Modeling/WathMTKdo/">MTK的&quot;前世今生&quot;</a></li><li><a class="tocitem" href="../../Modeling/ProcesSys/">浅谈流程建模</a></li></ul></li><li><span class="tocitem">Simulation</span><ul><li><a class="tocitem" href="../componementModel/">组件化建模实例</a></li><li><a class="tocitem" href="../steadyRC/">MTK稳态系统仿真实例</a></li><li class="is-active"><a class="tocitem" href>MTK手动空间离散求解PDE</a><ul class="internal"><li><a class="tocitem" href="#MTK的PDE求解技巧"><span>MTK的PDE求解技巧</span></a></li><li><a class="tocitem" href="#数值传热学实例"><span>数值传热学实例</span></a></li><li><a class="tocitem" href="#求解实例"><span>求解实例</span></a></li></ul></li><li><a class="tocitem" href="../DE_heattran/">DE求解PDE（对比MTK）</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../Optimization/参数辨识实例_MTK/">MTK非线性参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/JuMP参数辨识/">JuMP非线性参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/DE_Estim/">微分方程参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/systemParaEste/">MTK符号系统参数辨识</a></li></ul></li><li><span class="tocitem">Control</span><ul><li><a class="tocitem" href="../../Control/MTKMPC/">MTK求解MPC问题</a></li><li><a class="tocitem" href="../../Control/JuMPMPC/">JuMP求解MPC问题</a></li><li><a class="tocitem" href="../../Control/OptimControl/">最优控制理论与应用</a></li></ul></li><li><span class="tocitem">CS Base</span><ul><li><a class="tocitem" href="../../CS Base/env_variable/">环境（变量）的本质</a></li><li><a class="tocitem" href="../../CS Base/julia的安装/">Julia安装</a></li><li><a class="tocitem" href="../../CS Base/julia_change_pkgserve/">Julia换源(更换国内镜像站)</a></li><li><a class="tocitem" href="../../CS Base/Creat and Call dll/">动态链接库(DLL)的生成与调用</a></li><li><a class="tocitem" href="../../CS Base/SSH_Git/">SSH、Git与Git图形化软件</a></li></ul></li><li><span class="tocitem">Tools</span><ul><li><a class="tocitem" href="../../Tools/CoolProp/">CoolProp使用介绍</a></li><li><a class="tocitem" href="../../Tools/CSV_jl_use/">CVS.jl使用简介</a></li><li><a class="tocitem" href="../../Tools/vscode_git/">VScode中使用Git</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Simulation</a></li><li class="is-active"><a href>MTK手动空间离散求解PDE</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MTK手动空间离散求解PDE</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jake484/LearnDocs/blob/master/docs/src/Simulation/MTK_heattran.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MTK手动空间离散求解PDE"><a class="docs-heading-anchor" href="#MTK手动空间离散求解PDE">MTK手动空间离散求解PDE</a><a id="MTK手动空间离散求解PDE-1"></a><a class="docs-heading-anchor-permalink" href="#MTK手动空间离散求解PDE" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Contents：MTK、PDE、手动空间离散</p><p>Contributor: YJY</p><p>Email:522432938@qq.com</p><p>如有错误，请批评指正。</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>MTK = ModelingToolkit.jl</p><p>PDE = Partial Differential Equation</p><p><a href="https://mtk.sciml.ai/stable/">ModelingToolkit.jl </a>符号建模包</p></div></div><h2 id="MTK的PDE求解技巧"><a class="docs-heading-anchor" href="#MTK的PDE求解技巧">MTK的PDE求解技巧</a><a id="MTK的PDE求解技巧-1"></a><a class="docs-heading-anchor-permalink" href="#MTK的PDE求解技巧" title="Permalink"></a></h2><p>在之前介绍的例子中，所有的微分都是基于时间的微分。从数学的角度来说，微分变量只有一个。而对于有多个微分变量的PDE问题，能否通过MTK手动求解呢？例如，对时间对空间微分的PDE问题。</p><p>答案是肯定的。</p><hr/><p>求解PDE的数值方法有这么几步：</p><ul><li>建立数学描述方程</li><li>对变量进行离散</li><li>迭代求解</li></ul><p>MTK用法中，提供了<strong>基于时间的一条龙求解</strong>。至于多变量的PDE，也有对应的<a href="https://mtk.sciml.ai/stable/systems/PDESystem/">PDESystem</a>。但是目前来说，PDESystem还不是很完善。其离散方法涉及<a href="https://neuralpde.sciml.ai/stable/">NeuralPDE.jl</a>的相关内容。就MTK.jl本身来说，没有打通PDE的建模与求解过程。</p><hr/><p>所以，使用MTK求解PDE的缺口在于，<strong>没有针对其它变量的离散——空间离散</strong>。那么，如果我们能够手动完成空间离散，这个问题就解决了。事实上，手动空间离散是可行的。</p><h2 id="数值传热学实例"><a class="docs-heading-anchor" href="#数值传热学实例">数值传热学实例</a><a id="数值传热学实例-1"></a><a class="docs-heading-anchor-permalink" href="#数值传热学实例" title="Permalink"></a></h2><p>考虑一个正方形铸件的散热过程，正方形铸件初始温度1000℃，环境温度为0℃。如图</p><p><img src="../../assets/heattran-10_40_55.png" alt="图 1"/>  </p><p>传热的控制方程为：</p><p class="math-container">\[\rho c_{p} \frac{\partial T}{\partial t}=\lambda(\frac{\partial^{2} T}{\partial x^{2}} +\frac{\partial^{2} T}{\partial y^{2}})\]</p><p>将参数统一在等式右端，即</p><p class="math-container">\[\frac{\partial T}{\partial t}=a(\frac{\partial^{2} T}{\partial x^{2}}+\frac{\partial^{2} T}{\partial y^{2}})\]</p><p>其中，</p><p class="math-container">\[\rho——密度，单位为：\frac{kg}{m^3}\]</p><p class="math-container">\[c_p——物体热容，单位为：\frac{J}{kg\cdot k}\]</p><p class="math-container">\[\lambda——导热系数，单位为：\frac{W}{m\cdot k}\]</p><p class="math-container">\[a——热扩散系数，单位为：\frac{m^2}{s}\]</p><h3 id="内部节点空间离散"><a class="docs-heading-anchor" href="#内部节点空间离散">内部节点空间离散</a><a id="内部节点空间离散-1"></a><a class="docs-heading-anchor-permalink" href="#内部节点空间离散" title="Permalink"></a></h3><p>对方程进行空间离散，采用二阶中心差分，有：</p><p class="math-container">\[\frac{\partial T_{i,j}}{\partial t}=a (\frac{T_{i+1, j}^{n}- 2 T_{i, j}^{n}+T_{i-1, j}^{n}}{\Delta x^{2}}+\frac{T_{i, j+1}^{n}- 2 T_{i, j}^{n}+T_{i, j-1}^{n}}{\Delta y^{2}})\]</p><p>若使用化简表达，</p><p class="math-container">\[\Delta x = \Delta y = \delta\\T_{i, j}=T_P,T_{i+1, j}=T_{W},T_{i-1, j}=T_{E},T_{i, j-1}=T_{N},T_{i, j+1}=T_{S}\]</p><p>则有<strong>内部节点的空间离散</strong>：</p><p class="math-container">\[\frac{\partial T}{\partial t}=\frac{a}{\delta^{2}}(T_{W}^{n}+T_{E}^{n}+T_{N}^{n}+T_{S}^{n} - 4T_{P}^{n})\]</p><h3 id="边边界空间离散"><a class="docs-heading-anchor" href="#边边界空间离散">边边界空间离散</a><a id="边边界空间离散-1"></a><a class="docs-heading-anchor-permalink" href="#边边界空间离散" title="Permalink"></a></h3><p>下面考虑边界条件。以W边为例。</p><p><img src="../../assets/heattran-11_05_12.png" alt="图 2"/>  </p><p>边界条件使用第三类边界条件。</p><p class="math-container">\[\delta h(T_{f}-T_{W}^{n})=\delta \lambda \frac{T_{W}^{n}-T_{P}^{n}}{\frac{\delta}{2}}\]</p><p>为了消去<span>$T_{W}^{n}$</span>，考虑该式子的等比式：</p><p class="math-container">\[\frac{(T_{f}-T_{W}^{n})}{\frac{1}{h}}=\frac{T_{W}^{n}-T_{P}^{n}}{\frac{\delta}{2 \lambda}}=\frac{(T_{f}-T_{P}^{n})}{\frac{1}{h}+\frac{\delta}{2 \lambda}} \tag{a}\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>当对流散热系数h足够大时，<span>$\frac{2\lambda}{\delta h}\approx0$</span>，即<span>$T_W \approx T_f$</span>。第三类边界条件可以近似为第一类边界条件——<strong>壁温恒定为环境温度</strong>，如下式推导：</p><p class="math-container">\[T_{W}=\frac{h T_{f}+\frac{2 \lambda}{\delta} T_{P}^{n}}{h+\frac{2 \lambda}{\delta}}=\frac{T_{f}+\frac{2 \lambda}{\delta h} T_{P}^{n}}{1+\frac{2 \lambda}{\delta h}} \approx T_f\]</p><p>这是从数学上的一种理解，后面并没使用到该近似。</p></div></div><p>对边界采用附加源法进行分析。<span>$T_W$</span>为边界点温度，<span>$T_P$</span>节点的能量守恒方程为：</p><p class="math-container">\[\begin{array}{c}\delta \lambda \frac{T_{E}^{n}-T_{P}^{n}}{\delta}+\delta \lambda \frac{T_{N}^{n}-T_{P}^{n}}{\delta}+\delta \lambda \frac{T_{S}^{n}-T_{P}^{n}}{\delta}+\delta \lambda \frac{T_{W}^{n}-T_{P}^{n}}{\frac{\delta}{2}}=\rho c \delta^{2} \frac{\partial T_P}{\partial t}\end{array}\]</p><p>将式(a)的第三项代入上式中的<span>$T_W-T_P$</span>项并化简，最终能得到边边界的边界方程：</p><p class="math-container">\[\begin{array}{c}\frac{\partial T_P}{\partial t}=\frac{a }{\delta^{2}}(T_{E}^{n}+T_{N}^{n} + T_{S}^{n})-(\frac{a}{\frac{\lambda \delta}{h}+\frac{\delta^{2}}{2}}+\frac{3 a }{\delta^{2}}) T_{P}^{n}+\frac{a }{\frac{\lambda \delta}{h}+\frac{\delta^{2}}{2}} T_{f}\end{array}\]</p><p>同理可得其它3个边的边边界方程。</p><h3 id="角边界空间离散"><a class="docs-heading-anchor" href="#角边界空间离散">角边界空间离散</a><a id="角边界空间离散-1"></a><a class="docs-heading-anchor-permalink" href="#角边界空间离散" title="Permalink"></a></h3><p>最后考虑<strong>角边界</strong>。以铸件左上角为例进行分析，下如图所示的角边界。</p><p><img src="../../assets/heattran-11_36_05.png" alt="图 3"/>  </p><p>分析方法同边边界的分析方法，最后可得：</p><p class="math-container">\[\frac{\partial T_P}{\partial t}=\frac{a}{\delta^{2}}(T_{E}^{n}+T_{N}^{n}+T_{S}^{n})-(\frac{a}{\frac{\lambda \delta}{h}+\frac{\delta^{2}}{2}}+\frac{2a}{\delta^{2}}) T_{P}^{n}+\frac{2a}{\frac{\lambda \delta}{h}+\frac{\delta^{2}}{2}} T_{f}\]</p><h3 id="离散方程汇总"><a class="docs-heading-anchor" href="#离散方程汇总">离散方程汇总</a><a id="离散方程汇总-1"></a><a class="docs-heading-anchor-permalink" href="#离散方程汇总" title="Permalink"></a></h3><p>经过以上推导，得到了内节点表达式、边边界表达式和角边界表达式。为了方便程序表达，对方程的系数进行化简，令，</p><p class="math-container">\[A = \frac{a}{\delta^2}，B = \frac{a}{\frac{\lambda\delta}{h}+\frac{\delta^{2}}{2}}\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>当<span>$h$</span>很大时，<span>$\frac{\lambda \delta}{h}\approx 0$</span>，所以<span>$B \approx 2A$</span>。和前面边界条件的理解相似。同样的，这只是一种理解方式，并没有使用。</p></div></div><p>内节点：</p><p class="math-container">\[\frac{\partial T_P}{\partial t}=A(T_W^n+T_E^n{+\ T}_N^n+T_S^n - 4T_P^n)\]</p><p>边边界节点：</p><p class="math-container">\[\frac{\partial T_P}{\partial t}=A(T_W^n{+T}_N^n+T_S^n)-(B+3A)T_P^n+BT_f\]</p><p>角边界节点：</p><p class="math-container">\[\frac{\partial T_P}{\partial t}=A(T_E^n\ {+\ T}_N^n\ )-(2B+2A)T_P^n+2BT_f\]</p><h2 id="求解实例"><a class="docs-heading-anchor" href="#求解实例">求解实例</a><a id="求解实例-1"></a><a class="docs-heading-anchor-permalink" href="#求解实例" title="Permalink"></a></h2><p>求解的全部代码如下：</p><pre><code class="language-julia hljs">using ModelingToolkit, DifferentialEquations

# 参数设定
a = 1.27E-5
n = 10
L = 0.2
δ = L / n
λ = 50
h = 1.0E9
Tf = 0.0
A = a / δ^2
B = a / (δ^2 / 2 + δ * λ / h)

@variables t T[1:n, 1:n](t)

D = Differential(t)

# 内节点代码
insides = [
    D(T[i, j]) ~ A * (T[i+1, j] + T[i-1, j] + T[i, j+1] + T[i, j-1] - 4 * T[i, j])
    for i in 2:n-1 for j in 2:n-1]

# 边边界代码
Wb = [
    D(T[i, 1]) ~ A * (T[i+1, 1] + T[i-1, 1] + T[i, 2]) - (3B + A) * T[i, 1] + B * Tf
    for i in 2:n-1
]
Eb = [
    D(T[i, n]) ~ A * (T[i+1, n] + T[i-1, n] + T[i, n-1]) - (3B + A) * T[i, n] + B * Tf
    for i in 2:n-1
]
Nb = [
    D(T[1, i]) ~ A * (T[1, i+1] + T[1, i-1] + T[2, i]) - (3B + A) * T[1, i] + B * Tf
    for i in 2:n-1
]
Sb = [
    D(T[n, i]) ~ A * (T[n, i+1] + T[n, i-1] + T[n-1, i]) - (3B + A) * T[1, i] + B * Tf
    for i in 2:n-1
]

# 4 corner boundary
corner = [
    D(T[1, 1]) ~ A * (T[2, 1] + T[1, 2]) - (2B + 2A) * T[1, 1] + 2B * Tf,
    D(T[n, n]) ~ A * (T[n-1, n] + T[n, n-1]) - (2B + 2A) * T[n, n] + 2B * Tf,
    D(T[n, 1]) ~ A * (T[n, 2] + T[n-1, 1]) - (2B + 2A) * T[n, 1] + 2B * Tf,
    D(T[1, n]) ~ A * (T[2, n] + T[1, n-1]) - (2B + 2A) * T[1, n] + 2B * Tf
]

eqs = append!(insides, Wb, Eb, Nb, Sb, corner)

@named sys = ODESystem(eqs, t)

sys = structural_simplify(sys)

# u0 = [1000.0 for i in 1:n for j in 1:n]
u0 = Dict(T[i, j] =&gt; 1000.0 for i in 1:n for j in 1:n)
prob = ODEProblem(sys, u0, (0, 100), [], saveat=0.1)
sol = solve(prob, Tsit5())
</code></pre><p>值得一提的是：</p><hr/><p><code>MTK变量定义</code>:</p><p>这是有效的变量数组（矩阵）的定义方式，也就是说MTK支持变量数运算。</p><pre><code class="language-julia hljs">@variables t T[1:n, 1:n](t)</code></pre><hr/><p><code>ODESystem定义</code></p><p>ODESystem定义时，既没有传递变量，也没有传递参数，甚至连t也可以不用传递，这都是可行的。ODESystem定义时能够自动检查（check）方程结构，从方程中获得变量信息。</p><pre><code class="language-julia hljs">@named sys = ODESystem(eqs, t)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>ODESystem定义时，若传递变量数组或者参数数组，check时不能通过。目前来说这是一个bug，所以可以不写。</p></div></div><hr/><p><code>MTK初值设定</code></p><p>初值或者参数传递时，以下两种方式都可以。但也有区别。在符号计算中，符号在数组中的位置是不确定的。假如以数组的形式传递进去，那么就不知道哪个初值传递给了哪个变量（如果初值或参数都相同那就无所谓）。所以，初值传递需要精确到变量时，最好使用Dict。</p><pre><code class="language-julia hljs">
u0 = [1000.0 for i in 1:n for j in 1:n]

u0 = Dict(T[i, j] =&gt; 1000.0 for i in 1:n for j in 1:n)</code></pre><hr/><p><code>saveat</code></p><p>saveat是solution handle中的内容。其作用是使sol中结果存储结果的时间步长为给定步长。</p><p>当然，也可以使用<code>sol()</code>获得任意时刻的值。</p><pre><code class="language-julia hljs">sol(2.5)</code></pre><p>但是这样会丢失变量的顺序，就是无法得知变量与数值的对应关系了。<strong>能否解决这个问题，这里还有许多可测试与探索的空间</strong>。</p><hr/><h3 id="可视化"><a class="docs-heading-anchor" href="#可视化">可视化</a><a id="可视化-1"></a><a class="docs-heading-anchor-permalink" href="#可视化" title="Permalink"></a></h3><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Julia生态中，可视化也是很强的！</p><p><a href="https://docs.juliaplots.org/dev/">Plots.ji</a>远比想象的强大！</p></div></div><p>最后，<strong>动画</strong>走你！</p><pre><code class="language-julia hljs">an_len= length(sol[T[1,1]])
using Plots, GR
res = rand(n,n,an_len)
for t in 1:an_len
    for i in 1:n
        for j in 1:n
            res[i,j,t] = sol[T[i,j]][t]
        end
    end
end
xs = LinRange(0.0, L, n)
ys = LinRange(0.0, L, n)
contourf!(xs, ys, res[:,:,10])
anim = @animate for i ∈ 1:50
    contourf!(xs, ys, res[:,:,i])
end
gif(anim, &quot;anim.gif&quot;, fps = 24)</code></pre><p><img src="../../assets/anim_fps15.gif" alt/></p><p>物体温度是下降的，在不断散热。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../steadyRC/">« MTK稳态系统仿真实例</a><a class="docs-footer-nextpage" href="../DE_heattran/">DE求解PDE（对比MTK） »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Wednesday 11 May 2022 07:24">Wednesday 11 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
