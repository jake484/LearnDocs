<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DE求解PDE（对比MTK） · LearnDocs</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.jpg" alt="LearnDocs logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LearnDocs</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Modeling</span><ul><li><a class="tocitem" href="../../Modeling/DE_intro/">DifferentialEquations建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_intro/">ModelingToolkit建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_register/">ModelingToolkit调用外部函数</a></li><li><a class="tocitem" href="../../Modeling/WathMTKdo/">MTK的&quot;前世今生&quot;</a></li><li><a class="tocitem" href="../../Modeling/ProcesSys/">浅谈流程建模</a></li></ul></li><li><span class="tocitem">Simulation</span><ul><li><a class="tocitem" href="../componementModel/">组件化建模实例</a></li><li><a class="tocitem" href="../steadyRC/">MTK稳态系统仿真实例</a></li><li><a class="tocitem" href="../MTK_heattran/">MTK手动空间离散求解PDE</a></li><li class="is-active"><a class="tocitem" href>DE求解PDE（对比MTK）</a><ul class="internal"><li><a class="tocitem" href="#DE求解PDE"><span>DE求解PDE</span></a></li><li><a class="tocitem" href="#数值传热学实例"><span>数值传热学实例</span></a></li><li><a class="tocitem" href="#求解实例"><span>求解实例</span></a></li><li><a class="tocitem" href="#求解速度对比"><span>求解速度对比</span></a></li><li><a class="tocitem" href="#关于内涵的理解"><span>关于内涵的理解</span></a></li></ul></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../Optimization/参数辨识实例_MTK/">MTK非线性参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/JuMP参数辨识/">JuMP非线性参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/DE_Estim/">微分方程参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/systemParaEste/">MTK符号系统参数辨识</a></li></ul></li><li><span class="tocitem">Control</span><ul><li><a class="tocitem" href="../../Control/MTKMPC/">MTK求解MPC问题</a></li><li><a class="tocitem" href="../../Control/JuMPMPC/">JuMP求解MPC问题</a></li></ul></li><li><span class="tocitem">CS Base</span><ul><li><a class="tocitem" href="../../CS Base/env_variable/">环境（变量）的本质</a></li><li><a class="tocitem" href="../../CS Base/julia的安装/">Julia安装</a></li><li><a class="tocitem" href="../../CS Base/julia_change_pkgserve/">Julia换源(更换国内镜像站)</a></li><li><a class="tocitem" href="../../CS Base/Creat and Call dll/">动态链接库(DLL)的生成与调用</a></li><li><a class="tocitem" href="../../CS Base/SSH_Git/">SSH、Git与Git图形化软件</a></li></ul></li><li><span class="tocitem">Tools</span><ul><li><a class="tocitem" href="../../Tools/CoolProp/">CoolProp使用介绍</a></li><li><a class="tocitem" href="../../Tools/CSV_jl_use/">CVS.jl使用简介</a></li><li><a class="tocitem" href="../../Tools/vscode_git/">VScode中使用Git</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Simulation</a></li><li class="is-active"><a href>DE求解PDE（对比MTK）</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DE求解PDE（对比MTK）</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jake484/LearnDocs/blob/master/docs/src/Simulation/DE_heattran.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DE求解PDE（对比MTK）"><a class="docs-heading-anchor" href="#DE求解PDE（对比MTK）">DE求解PDE（对比MTK）</a><a id="DE求解PDE（对比MTK）-1"></a><a class="docs-heading-anchor-permalink" href="#DE求解PDE（对比MTK）" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Contents：DE、PDE、手动空间离散</p><p>Contributor: YJY</p><p>Email:522432938@qq.com</p><p>如有错误，请批评指正。</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>DE = DifferentialEquations.jl</p><p>PDE = Partial Differential Equation</p><p><a href="https://diffeq.sciml.ai/dev/">DifferentialEquations.jl</a>为处理时间微分的求解建模工具包。</p></div></div><h2 id="DE求解PDE"><a class="docs-heading-anchor" href="#DE求解PDE">DE求解PDE</a><a id="DE求解PDE-1"></a><a class="docs-heading-anchor-permalink" href="#DE求解PDE" title="Permalink"></a></h2><p>在<a href="../MTK_heattran/">MTK手动空间离散求解PDE</a>中介绍了手动空间离散的思想。本篇中将通过手动PDE求解传热问题对DE与MTK进行一个小对比。</p><hr/><p>DE构建的问题过程中，需要把问题推演至求解之前。求解之前的部分都需要手动完成。<a href="../MTK_heattran/">MTK手动空间离散求解PDE</a>中提到，求解PDE的数值方法有这么几步：建立数学描述方程、对变量进行离散、迭代求解。</p><p>把问题进一步细化，则变为：</p><ul><li>Step1:建立数学描述方程</li><li>Step2:网格生成（变量离散）</li><li>Step3:生成求解格式</li><li>Step4:迭代求解</li></ul><p>MTK完成了Step3、Step4的内容，而DE只能帮我们完成Step4的内容。</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>如果我们仔细琢磨，会发现：如果是基于时间微分的组件化建模。使用MTK时，我们完成Step1的内容，剩下MTK全包了！所以这也是为什么说，MTK提供了<strong>基于时间的一条龙求解</strong>。</p></div></div><hr/><p>我们来看看，DE是如何完成Step4的内容的。同时，也会让大家对数值求解过程有一个更加深刻的理解。</p><h2 id="数值传热学实例"><a class="docs-heading-anchor" href="#数值传热学实例">数值传热学实例</a><a id="数值传热学实例-1"></a><a class="docs-heading-anchor-permalink" href="#数值传热学实例" title="Permalink"></a></h2><p>考虑<a href="../MTK_heattran/">MTK手动空间离散求解PDE</a>中正方形铸件的散热过程。节点的离散结果如下（不再推导）：</p><p>内节点：</p><p class="math-container">\[\frac{\partial T_P}{\partial t}=A(T_W^n+T_E^n{+\ T}_N^n+T_S^n - 4T_P^n)\]</p><p>边边界节点：</p><p class="math-container">\[\frac{\partial T_P}{\partial t}=A(T_W^n{+T}_N^n+T_S^n)-(B+3A)T_P^n+BT_f\]</p><p>角边界节点：</p><p class="math-container">\[\frac{\partial T_P}{\partial t}=A(T_E^n\ {+\ T}_N^n\ )-(2B+2A)T_P^n+2BT_f\]</p><p>这里，我们进一步对问题进行拓展。正方形铸件初始温度1000℃，环境温度为一个变化的值：</p><p class="math-container">\[T_f = 400 * (1 + sin(t))\]</p><h2 id="求解实例"><a class="docs-heading-anchor" href="#求解实例">求解实例</a><a id="求解实例-1"></a><a class="docs-heading-anchor-permalink" href="#求解实例" title="Permalink"></a></h2><p>求解的全部代码如下：</p><pre><code class="language-julia hljs">using ModelingToolkit, DifferentialEquations
using Dates

println(&quot;=====DE TEST=====&quot;)
starttime = now()
a = 1.27E-5
n = 10
L = 0.2
δ = L / n
λ = 50
h = 1.0E9
Tf = 0.0
A = a / δ^2
B = a / (δ^2 / 2 + δ * λ / h)
p = [A, B, n]
function to_index(i, j, n)
    return (i - 1) * n + j
end
function heat!(dT, T, p, t)
    A, B, n = p
    n = Int(n)
    Tf = 400.0 * (1 + sin(t))
    # 内部节点
    for i in 2:n-1
        for j in 2:n-1
            dT[to_index(i, j, n)] = A * (T[to_index(i + 1, j, n)] + T[to_index(i - 1, j, n)] + T[to_index(i, j + 1, n)] + T[to_index(i, j - 1, n)] - 4 * T[to_index(i, j, n)])
        end
    end
    # 边边界
    for i in 2:n-1
        dT[to_index(i, 1, n)] = A * (T[to_index(i + 1, 1, n)] + T[to_index(i - 1, 1, n)] + T[to_index(i, 2, n)]) - (3B + A) * T[to_index(i, 1, n)] + B * Tf
    end
    for i in 2:n-1
        dT[to_index(i, n, n)] = A * (T[to_index(i + 1, n, n)] + T[to_index(i - 1, n, n)] + T[to_index(i, n - 1, n)]) - (3B + A) * T[to_index(i, n, n)] + B * Tf
    end
    for i in 2:n-1
        dT[to_index(1, i, n)] = A * (T[to_index(1, i + 1, n)] + T[to_index(1, i - 1, n)] + T[to_index(2, i, n)]) - (3B + A) * T[to_index(1, i, n)] + B * Tf
    end
    for i in 2:n-1
        dT[to_index(n, i, n)] = A * (T[to_index(n, i + 1, n)] + T[to_index(n, i - 1, n)] + T[to_index(n - 1, i, n)]) - (3B + A) * T[to_index(1, i, n)] + B * Tf
    end
    # 角边界
    dT[to_index(1, 1, n)] = A * (T[to_index(2, 1, n)] + T[to_index(1, 2, n)]) - (2B + 2A) * T[to_index(1, 1, n)] + 2B * Tf
    dT[to_index(n, n, n)] = A * (T[to_index(n - 1, n, n)] + T[to_index(n, n - 1, n)]) - (2B + 2A) * T[to_index(n, n, n)] + 2B * Tf
    dT[to_index(n, 1, n)] = A * (T[to_index(n, 2, n)] + T[to_index(n - 1, 1, n)]) - (2B + 2A) * T[to_index(n, 1, n)] + 2B * Tf
    dT[to_index(1, n, n)] = A * (T[to_index(2, n, n)] + T[to_index(1, n - 1, n)]) - (2B + 2A) * T[to_index(1, n, n)] + 2B * Tf
end
u0 = [1000.0 for i in 1:n for j in 1:n]
prob = ODEProblem(heat!, u0, (0, 100), p, saveat=1)
sol = solve(prob, Tsit5())
endtime = now()
println(&quot;time use:&quot;*string(endtime - starttime))</code></pre><h3 id="可视化"><a class="docs-heading-anchor" href="#可视化">可视化</a><a id="可视化-1"></a><a class="docs-heading-anchor-permalink" href="#可视化" title="Permalink"></a></h3><p><strong>动画</strong>走你！</p><pre><code class="language-julia hljs">an_len = length(sol.u)
using Plots, GR
res = rand(n, n, an_len)
for t in 1:an_len
    for i in 1:n
        for j in 1:n
            res[i, j, t] = sol.u[t][to_index(i, j, n)]
        end
    end
end
xs = LinRange(0.0, L, n)
ys = LinRange(0.0, L, n)
anim = @animate for i ∈ 1:an_len
    contourf!(xs, ys, res[:, :, i])
end
gif(anim, &quot;DE_trans.gif&quot;, fps=24)</code></pre><p><img src="../../assets/DE_trans.gif" alt="1"/></p><p>以上代码对比之前，有所改变的是：</p><p><code>saveat</code></p><p>我们把时间拉长，同时saveat的时间步长变成了1s。</p><hr/><h2 id="求解速度对比"><a class="docs-heading-anchor" href="#求解速度对比">求解速度对比</a><a id="求解速度对比-1"></a><a class="docs-heading-anchor-permalink" href="#求解速度对比" title="Permalink"></a></h2><p>跑相同的问题：</p><ul><li>MTK用时：2.407s</li><li>DE用时：0.810s</li></ul><p>可见，Step3的符号化简与DE问题生成的确需要消耗不少的资源。</p><h2 id="关于内涵的理解"><a class="docs-heading-anchor" href="#关于内涵的理解">关于内涵的理解</a><a id="关于内涵的理解-1"></a><a class="docs-heading-anchor-permalink" href="#关于内涵的理解" title="Permalink"></a></h2><p>MTK与DE两种方法都能够求解PDE问题。为什么这样做能行呢？下面分享一些关于问题内涵的思考。</p><h3 id="空间离散的物理内涵"><a class="docs-heading-anchor" href="#空间离散的物理内涵">空间离散的物理内涵</a><a id="空间离散的物理内涵-1"></a><a class="docs-heading-anchor-permalink" href="#空间离散的物理内涵" title="Permalink"></a></h3><p>动画中可以清晰感受到外围颜色的震动，这是我们设定环境温度波动的结果。若要把环境温度变化以微分方程的形式定义，同样可行。只需要再添加一个变量关于时间相关的变量即可。而这个随时间的变化的环境温度，是真正驱动系统变化的变量，它的变化是由时间决定，而不受其它网格影响。相反，其它网格受到环境温度变量的影响。可以说，环境温度变量是独立于网格离散而存在的。</p><p>由此，我们可以聊一聊关于空间离散的内涵。</p><p>在以上的传热实例中，<strong>系统的根本“驱动力”在于温差</strong>。也就是说，因为温差的存在，才会让系统产生变化。而我们在空间离散时，其实并没有对这种变化进行处理。我们手动空间离散的内涵是：<strong>在不同网格间，架起了让网格相互联系的桥梁</strong>。其本质描述了网格和网格之间的联系。</p><p>从高数中微元的角度思考，只要网格足够小，那么我们就可以得到非常精确的模拟结果；从物理内涵的角度思考，不管网格如何小，任何一个网格都可以视为一个小组件，这个小组件的特性有：温度、边长、导热系数等等，并且在小组件内部，这些属性的数值视为不变。而空间离散，就是建立了这些小组件之间的关联。这种思想在数值计算领域是一种专业的离散方式——有限容积法。</p><p>所以，以上空间离散的思想内涵就和之间组件化建模的思想内涵统一起来了。区别在于，空间离散出来的结果是微元，组件化建模的模型结果是宏观组件。 但是，不同组件（微元）之间需要建立相互联系的桥梁这一点是不变的。</p><p>如果深入思考传热的内涵——由温差引起的热量传递。我们也能发现，以小组件的形式看待微元网格，其物理逻辑也是非常自洽的。</p><p>把空间离散赋予物理内涵（微元组件化）后，剩下的问题也很清晰了——组件在时间域上的变化。组件之间的连接建立好之后，当外界环境（温度）随时间动态变化，组件的属性（温度）也会发生相应的变化。这不就是时间域上动态系统的求解内涵吗？只是我们不会把描述时间微分的方程离散，而是把它丢给求解器去解。</p><h3 id="迭代格式的数学内涵"><a class="docs-heading-anchor" href="#迭代格式的数学内涵">迭代格式的数学内涵</a><a id="迭代格式的数学内涵-1"></a><a class="docs-heading-anchor-permalink" href="#迭代格式的数学内涵" title="Permalink"></a></h3><p>迭代格式数学内涵中最关键的一环是函数<code>to_index()</code></p><pre><code class="language-julia hljs">function to_index(i, j, n)
    return (i - 1) * n + j
end</code></pre><p>MTK中采用<code>T[i, j]</code>的网格描述方式，这是从物理位置中对网格进行了一种描述。这种描述中是附加由物理含义的——空间位置。而这种附加了物理含义的变量描述，底层求解器是无法求解的。</p><p>DE能求解的方程是什么样的呢？如下所示：</p><p class="math-container">\[\left\{\begin{array}{c}
y_{1}^{\prime}(x)=f\left(x, y_{1}(x), y_{2}(x), \ldots, y_{n}(x) \right) \\y_{2}^{\prime}(x)=f\left(x, y_{1}(x), y_{2}(x), \ldots, y_{n}(x) \right) \\ \ldots \\y_{n}^{\prime}(x)=f\left(x, y_{1}(x), y_{2}(x), \ldots, y_{n}(x) \right) \\ y_{1}\left(x_{0}\right)=y_{10}, y_{2}\left(x_{0}\right)=y_{20}, \ldots, y_{n}\left(x_{0}\right)=y_{n 0}\end{array}\right.\]</p><p>写成统一的格式即：</p><p class="math-container">\[\mathbf{y}\prime=\mathbf{f}(\mathbf{x},\mathbf{y})\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>求解微分方程的数值解法主要有：</p><ul><li>欧拉法</li></ul><p class="math-container">\[w\]</p><ul><li>后退欧拉法</li></ul><p class="math-container">\[y\left(x_{i+1}\right)=y\left(x_i\right)+hf\left(x_{i+1},{y(x}_{i+1})\right)+O\left(h^2\right)\]</p><ul><li>梯形法</li></ul><p class="math-container">\[y\left(x_{i+1}\right)=y\left(x_i\right)+\frac{h}{2}\left[f\left(x_i,y_i\ \right)+f\left(x_{i+1},y_{i+1}\right)\right]+O\left(h^3\right)\]</p><ul><li>辛普森方法</li></ul><p class="math-container">\[y\left(x_{i+1}\right)=y\left(x_{i-1}\right)+\\ \frac{h}{3}\left[f\left(x_{i-1},y_{i-1}\right)+4f\left(x_i,y_i\right)+f\left(x_{i+1},y_{i+1}\right)\right]+O\left(h^5\right)\]</p><ul><li>标准龙格库塔法</li></ul><p class="math-container">\[\left\{\begin{array}{c}
y_{i+1}=y_{i}+\frac{1}{6}\left(K_{1}+2 K_{2}+2 K_{3}+K_{4}\right) \\
K_{1}=h f\left(x_{i}, y_{i}\right) \\
K_{2}=h f\left(x_{i}+\frac{1}{2} h, y_{i}+\frac{1}{2} K_{1}\right) \\
K_{3}=h f\left(x_{i}+\frac{1}{2} h, y_{i}+\frac{1}{2} K_{2}\right) \\
K_{4}=h f\left(x_{i}+h, y_{i}+K_{3}\right)
\end{array}\right.\]</p><p>其中，h为求解的步长。</p><p>各方法阶数为（阶数越高精度越高）：</p><table><tr><th style="text-align: center">方法</th><th style="text-align: center">阶数</th></tr><tr><td style="text-align: center">欧拉法</td><td style="text-align: center">1阶</td></tr><tr><td style="text-align: center">后退欧拉法</td><td style="text-align: center">1阶</td></tr><tr><td style="text-align: center">梯形法</td><td style="text-align: center">2阶</td></tr><tr><td style="text-align: center">辛普森方法</td><td style="text-align: center">4阶</td></tr><tr><td style="text-align: center">标准龙格库塔法</td><td style="text-align: center">4阶</td></tr></table></div></div><p>对于这样的数学描述方式，<span>$y&#39;$</span>可以视为微分变量的数组，<span>$f(x,y)$</span>视为变量之间的联系。那么<span>$y&#39;=f(x,y)$</span>的含义是：微分与其它变量之间的关联。这种关联是不包含物理内涵的。而二维数组<code>T[i, j]</code>包含了位置关系。所以要去位置化，就需要把二维映射到一维上。所以我们采用<code>(i - 1) * n + j</code>将二维索引展平为一维。</p><p>本质是通过<code>to_index()</code>消除了物理位置含义。生成了DE可计算的描述方式——最原始最根本的微分方程组数学描述方式。这一步就是前面所说的Step3。</p><p>总的来看，DE求解我们手动完成了Step2、Step3、Step4。</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>MTK求解时。这一步由程序完成。</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MTK_heattran/">« MTK手动空间离散求解PDE</a><a class="docs-footer-nextpage" href="../../Optimization/参数辨识实例_MTK/">MTK非线性参数辨识实例 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Friday 6 May 2022 03:09">Friday 6 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
